[{"title":"clash for linux的使用","url":"/2021/04/10/linux/deepin-clash/","content":"写在前面emm我这里的网络访问Github实在是不稳定，同时也有去外网查询东西的需求，所以就考虑翻墙\n之前一直再用Clash所以就简单搞了搞\n下面就是Clash for Linux\n正文1.获取Clash for Linux\n前往Clash的Github的官方页面\n根据自己的架构下载对应的版本\n\n\n\n解压到合适的位置\n右键该文件 - 属性 - 权限管理 - 勾选允许以程序执行\n\n\n\n双击运行，此时 clash 已经在后台运行了，并且生成~/.config/clash文件夹\n\n\n2.配置第一次启动会在~/.config/clash目录下自动生成Config.yaml 和Country.mmdb两个文件。生成的Config.yaml文件为空，需要后续填写自己的代理信息。\n\n获取config.yaml文件\n前往订阅转换网站进行 yaml 文件的下载\n或者使用命令：（运行完成后会自动生成config.yaml文件，下载完成后覆盖config.yaml文件）\nrm -rf config.yaml &amp;&amp; wget -O config.yaml --no-check-certificate &quot;[订阅地址]&quot;\n获取country.mmdb文件\ncountry.mmdb文件为全球IP库，可以实现各个国家的IP信息解析和地理定位，自动下载的这个文件clash是无法运行的。\n这里提供一个country.mmdb下载地址 提取码: rwje，下载完成之后，将文件复制覆盖\n\n保持 clash-linux正在运行，浏览器访问 http://clash.razord.top 进行策略组设置\n\n连接控制中心\n找到控制中心-&gt;网络-&gt;系统代理-&gt;手动\n\n具体参数在 http://clash.razord.top 上面查看\n\n\n点击保存就可以使用啦！\n\n\n参考https://10101.io/2019/01/22/use-clash-linux-in-deepin\nhttps://www.jianshu.com/p/bdd80702de27\n","categories":["分享"],"tags":["clash","linux","机场"]},{"title":"Linux桌面版系统deepin（深度）安装","url":"/2021/04/10/linux/deepin-get/","content":"写在前面前几天突然脑袋一热一上头买了迷你主机打算用来安装linux系统供自己学习，然后经过几天的折腾我终于是把Deepin20.2成功安装并且目前比较稳定的运行下来。\n为什么不用虚拟机，emm我的笔记本VMware用不了，查找解决方式的时候，发现自己装的是win10家庭版有很多配置没有，或者修改起来很麻烦。就没用。\n我之前是在我的笔记本上尝试了Deepin+Windows双系统，虽然是成功了但是十分卡启动慢问题多，就干脆买了一个迷你主机。\n双系统安装\n\n我购买的是天虹的mini主机，配置如下，我在咸鱼半价买的二手，够用了\n\n\n正式开始1.Deepin介绍我来说一说为什么选择Deepin系统。\n\nDeepin是比较稳定的更新快，社区比较活跃，问题能够快速得到解答\nDeepin是桌面版，对于新手比较友好，而且可以一边看教程一边做，不用在其他的设备看教程\nDeepin是国产的！对中文支持很好\nDeepin的应用生态很好有自带的应用商店常用的比如QQ、微信都是有的，平时的沟通交流都是可以的\n\n2.准备下载镜像iso文件\n进入Deepin官网下载Deepin20.2。因为20.2版本3月31日才更新存在很多问题于是我下载了20.1\n\n本文将以20.1版本为例，20.2或者更古老的版本基本大同小异。\n\n\n下载启动盘制作工具\n进入Deepin官网下载深度启动盘制作工具\n\n准备一个空U盘3.制作启动盘\n打开深度启动盘制作工具选择下载的iso\n选择你的U盘（最好选择格式化成功概率高）\n制作\n\n4.安装\n把U盘插到迷你主机上\n进入bios界面在boot设置里找到自己U盘选择它\nBIOS一般是在开机的时候按Esc键，不同主板不太一样，不行的话建议百度\n进入U盘里Deepin安装系统\n有图形界面，在选择安装模式的时候直接全盘安装，我的迷你主机只有一个固态就直接选它\n然后一路下一步，等待安装完成\n重启，记得拔掉U盘！记得拔掉U盘！记得拔掉U盘！\n\n5.开启Deepin之旅重启后就正式进入了Deepin系统，还是很简单的嘛。\n建议在应用商店里下载所需的软件比如Chrome，WPS，搜狗输入法等等\n一些问题1.版本升级不知道为什么我安装微信，QQ之后关不了机，使用$shutdown now后开不了机\n所以我升级了一下从20.1到20.2。别问为什么不一开始就安20.2，问就是我不知道这个升级命令是升级系统的\n\n参考: https://blog.csdn.net/weixin_30700099/article/details/95527361\n\n\n打开终端输入，更新时间比较长请耐心等待\nsudo apt-get dist-upgrade\n在论坛看到很多升级过程卡住的，如果脸黑建议先使用20.1等过一阵官方修复了bug在更新\n\n2.无线网卡驱动好不容易升级完成，发现重启后无线网搜索不到了\n\n参考： https://bbs.deepin.org/en/post/218215\n\n\n删除原来的设备\n\nsudo apt remove --purge broadcom-sta*\n\n\n下载最新的驱动版本\n\nwget http:&#x2F;&#x2F;ftp.ru.debian.org&#x2F;debian&#x2F;pool&#x2F;non-free&#x2F;b&#x2F;broadcom-sta&#x2F;broadcom-sta-common_6.30.223.271-15~bpo10+1_all.debwget http:&#x2F;&#x2F;ftp.ru.debian.org&#x2F;debian&#x2F;pool&#x2F;non-free&#x2F;b&#x2F;broadcom-sta&#x2F;broadcom-sta-dkms_6.30.223.271-15~bpo10+1_all.debwget http:&#x2F;&#x2F;ftp.ru.debian.org&#x2F;debian&#x2F;pool&#x2F;non-free&#x2F;b&#x2F;broadcom-sta&#x2F;broadcom-sta-source_6.30.223.271-15~bpo10+1_all.deb\n\n\n安装驱动\n\nsudo dpkg -i broadcom-sta-common_6.30.223.271-15~bpo10+1_all.debsudo dpkg -i broadcom-sta-dkms_6.30.223.271-15~bpo10+1_all.debsudo dpkg -i broadcom-sta-source_6.30.223.271-15~bpo10+1_all.deb\n\n\n重启\n\n3. 搜狗输入法皮肤在官网下载的皮肤打不开\n解决：\n\n在应用商店安装Nautilus\n用Nautilus就可以打开皮肤文件了\n\n","categories":["分享"],"tags":["linux","Deepin"]},{"title":"deepin+windows双系统安装","url":"/2021/04/10/linux/deepin-windows/","content":"写在前面Windows+Deepin的双系统也会出现很多问题，我在安装的时候就出现了安装卡在一半等等问题，建议重新制作启动盘，修改各个分区的大小，有很多玄学。建议百度或者去官方论坛寻找答案\n1.准备下载镜像iso文件\n进入Deepin官网下载Deepin20.2。因为20.2版本3月31日才更新存在很多问题于是我下载了20.1\n本文将以20.1版本为例，20.2或者更古老的版本基本大同小异。\n\n下载启动盘制作工具\n进入Deepin官网下载深度启动盘制作工具\n\n准备一个空U盘2.制作启动盘\n打开深度启动盘制作工具选择下载的iso\n选择你的U盘（最好选择格式化成功概率高）\n制作\n\n3.磁盘分区\n我的电脑-右键-管理-存储-磁盘管理\n找到一个不用的盘符右键删除卷，一定要把其中的文件移出去，因为会格式化这个分区\n右键新建简单卷分配空间，视自己情况而定，一般50G+\n其他的空间可以再作为Windows的盘符\n\n4. 安装\n把U盘插到你的主机上，进入bios界面在boot设置里找到自己U盘选择它\nBIOS一般是在开机的时候按Esc键，不同主板不太一样，不行的话建议百度\n进入U盘里Deepin安装系统\n有图形界面，在选择安装模式的时候选择手动安装\n这里要分配空间，右下有删除，先找到你上一步分好的区，删除\n一定不要删错了！！！！\n从这一部分未分配的空间分出以下的区\n\n\n\n\n类型\n挂载点\n大小\n\n\n\next4\n/\n15G\n\n\next4\n/boot\n500M-1.5G或者默认\n\n\nfat32\n/boot/efi或者efi\n300M\n\n\n交换分区\n—\n4-8G\n\n\next4\n/home\n剩下所有\n\n\n\n然后一路下一步，等待安装完成\n重启，记得拔掉U盘！记得拔掉U盘！记得拔掉U盘！\n\n5.开启Deepin之旅重启进入BIOS，选择你安装Deepin的引导就正式进入了Deepin系统\n建议在应用商店里下载所需的软件比如Chrome，WPS，搜狗输入法等等\n我没有遇到回不去Windows的情况，如有问题，建议自行search on the internet\n","categories":["分享"],"tags":["linux","Deepin","双系统"]},{"title":"基于聚类分析的保护色动物识别","url":"/2022/04/12/mlClass/MLClass-1/","content":"前言这个人工智能挑战性课程太挑战了，这上来就让我们进行图片识别\n先说结论，仅采用聚类算法无法很好的识别保护色动物，所有没什么参考价值\n题目\n\n\n图片1\n图片2\n图片3\n\n\n\n\n\n\n\n\n使用聚类算法识别出上面图片中的动物\n实现准备工作\n安装所需的包\n\npip install Pillow\n\n\n\n算法原理k均值聚类方法\n选取初始聚类中心c1,c2···cn和迭代次数\n计算所有点到每个聚类中心的距离d1,d2···dn\n若dk = min{d1,d2···dn} 则将该点归到第k个聚类中\n每迭代完成后都根据聚类中所有点的均值重新计算聚类中心\n重复步骤2-4\n\n密度聚类\n计算每个点周围半径R之内的相似点个数\n若该值大于设定值，则该点是一个中心\n若一个中心的半径R之内的相似点中包含另一个中心，则将他们以及附属的相似点归为一类\n\n代码clusterFunimport randomimport PILfrom PIL import Imagefrom sklearn.cluster import KMeans# 打开图片def openPic(impath):    print(&#x27;正在打开图片&#x27;)    im = Image.open(impath)    w, h = im.size    return im, w, h# 获取每个像素信息def getPixel(im, width, height):    print(&#x27;正在获取像素信息&#x27;)    Im = im.load()    allPixel = []    for i in range(0, width):        allPixel.append([])        for j in range(0, height):            unit = (i, j) + Im[i, j]            allPixel[i].append(unit)    return allPixel# k均值聚类def kMeanColor(imgData, mCount, runTime, width, height):    print(&#x27;正在进行k均值计算···&#x27;)    # 距离计算函数    def dis(x, y, r, g, b, xc, yc, rc, gc, bc, a):        drgb = (r - rc) ** 2 + (g - gc) ** 2 + (b - bc) ** 2        dxy = (x - xc) ** 2 + (y - yc) ** 2        d = (a * dxy + (1 - a) * drgb) ** 0.5        return d        # 聚类中心计算函数    def countCenter(cData):        total = [0, 0, 0, 0, 0]        l = len(cData)        if l == 0:            return []        for i in range(0, l):            total[0] += cData[i][0]            total[1] += cData[i][1]            total[2] += cData[i][2]            total[3] += cData[i][3]            total[4] += cData[i][4]        newcenter = [int(total[0] / l), int(total[1] / l), int(total[2] / l), int(total[3] / l), int(total[4] / l)]        # print(newcenter)        return newcenter    # 随机选取聚类中心    M = []    for i in range(0, mCount):        munit = [random.randint(0, width), random.randint(0, height),                 random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)]        M.append(munit)    # k均值算法    # 迭代次数    for t in range(0, runTime):        C = []        for mC in range(0, mCount):            C.append([])        # 遍历每一个像素        for x in range(0, width):            for y in range(0, height):                c = 0                minDis = 10000000                # 计算每个样本到聚类中心的距离                for m in range(0, mCount):                    d = dis(imgData[x][y][0], imgData[x][y][1], imgData[x][y][2], imgData[x][y][3], imgData[x][y][4],                            M[m][0], M[m][1], M[m][2], M[m][3], M[m][4], 0.01)                    if d &lt; minDis:                        minDis = d                        c = m                C[c].append(imgData[x][y])        # 重新计算中心        for c in range(0, mCount):            newc = countCenter(C[c])            if len(newc) != 0:                M[c] = newc            else:                M[c][0] += 20                M[c][1] += 20                M[c][2] += 20                M[c][3] += 20                M[c][4] += 20    print(&#x27;聚类计算结束&#x27;)    return C, M# 展示图片def newIm(C, width, height):    l = len(C)    color = 50    im = Image.new(&#x27;RGB&#x27;, (width, height), (255, 255, 255))    rIm = im.load()    for i in range(0, l):        imi = Image.new(&#x27;RGB&#x27;, (width, height), (255, 255, 255))        rImi = imi.load()        for j in range(0, len(C[i])):            rIm[C[i][j][0], C[i][j][1]] = (color, color, color)            rImi[C[i][j][0], C[i][j][1]] = (color, color, color)        name=&#x27;result/&#x27;+str(i)+&#x27;.jpg&#x27;        imi.save(name, &#x27;JPEG&#x27;)        imi.close()        color += 20    im.save(&#x27;result/full.jpg&#x27;, &#x27;JPEG&#x27;)    return im\n\ntestimport clusterFunim, width, height = clusterFun.openPic(&#x27;pic/1.png&#x27;)pixelData = clusterFun.getPixel(im, width, height)cColor, mColor = clusterFun.kMeanColor(pixelData, 4, 3, width, height)imNew1 = clusterFun.newIm(cColor, width, height)imNew1.show()\n\n结果只能说图一乐\n\n","categories":["人工智能课程"],"tags":["python","study note","machine learning"]},{"title":"基于贝叶斯分类器的P图识别器","url":"/2022/04/14/mlClass/MLClass-2/","content":"前言这是第二个人工智能小组作业，这就挺离谱的。我仅仅根据上课所讲的贝叶斯分类器进行了简单的实现。没什么参考价值[doge]。这个题目可能用更高层的算法来实现更好，可惜我不会。\n题目\n所有图片均是人像\n提供两组训练集，其中一组是真实人脸，另一组是经过P图的人脸\n训练模型对测试集进行判断\n\n实现准备工作\n安装所需的包（opencv, dlib）\n\n# 通过pip进行安装pip install opencv-python# Cmake和Boost是dlib的前置pip install CMakepip install Boostpip install dlib# 通过anaconda进行安装conda install -c conda-forge dlib\n\n算法原理\n朴素贝叶斯分类是一种十分简单的分类算法，叫它朴素贝叶斯分类是因为这种方法的思想真的很朴素，朴素贝叶斯的思想基础是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。\n\n\n设x是一个待分类项，x有a1，a2···an 个特征\n已知类别集合C，其中有c1，c2···cn个类别\n计算P(c1|x),P(c2|x)···P(cn|x)\n若P(ck|x) = max{P(c1|x),P(c2|x)···P(cn|x)}，则将x分到第k类中\n这里P(ci|x) = P(ci) * P(a1|ci)·P(a2|ci)···P(an|ci)\n其中P(ai|ci)是通过训练集统计得出的\n\n\n参考：算法杂货铺——分类算法之朴素贝叶斯分类\n\n实现流程\n语言：python\n\n图片处理：opencv\n\n图片特征点获取：dlib\n\nshape_predictor_68_face_landmarks.dat\n特征点位置及编号如下图\n\n\n\n图片特征提取（目前仅选取五官位置）\n\n眼距差-宽度 feature0\n眼距差-高度 feature1\n左眼鼻底宽差距 feature2\n右眼鼻底宽差距 feature3\n眉心距-鼻底宽差 feature4\n下巴-鼻底-眉毛距离 feature5\n眼睛对称 feature6\n眉心-鼻心-嘴心差距 feature7\n\n\n模型训练\n\n找出训练集所有图片的特征\n根据朴素贝叶斯分类器原理分别统计出各个特征值对应的频率作为条件概率参数\n\n\n模型使用\n\n获取新图片的特征值\n和标准对比，并分别计算真假两类的概率\n概率大的则将其分到这类中\n\n\n\n代码find_feature.pyimport numpy as npimport osimport find_feature# 加载数据PC = np.loadtxt(&#x27;modle/PC.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)Pfr = np.loadtxt(&#x27;modle/real_p.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)Pff = np.loadtxt(&#x27;modle/fake_P.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)judge = [[1, 5], [0.35, 1.5], [4, 20], [4, 14], [7, 28], [9, 50], [6, 50], [15, 80]]result = []path_test = &#x27;dataset/testing&#x27;# 获取目录下图片数量l = len(os.listdir(path_test))n = 1# 遍历每一个图片for file in os.listdir(path_test):    # 获取该文件路径    file_path = os.path.join(path_test, file)    # 通过之前写的文件find_feature来获取该图片的特征值，存在F中    F = find_feature.find_feature(file_path)    # 判断待测图片特征值和目标特征值的范围，并乘以对应概率    Ptest = PC[:]    for i in range(0,8):        if F[i] ==-1:            break        elif F[i]&lt; judge[i][0]:            Ptest[0] = Ptest[0]*Pfr[i][0]            Ptest[1] = Ptest[1]*Pff[i][0]        elif F[i]&lt; judge[i][1]:            Ptest[0] = Ptest[0] * Pfr[i][1]            Ptest[1] = Ptest[1] * Pff[i][1]        else:            Ptest[0] = Ptest[0] * Pfr[i][2]            Ptest[1] = Ptest[1] * Pff[i][2]    # 如果将该图片为真的概率大于假的概率则将其判断为真    if Ptest[0]&gt;Ptest[1]:        result.append(1)    else:        result.append(-1)    # 显示目前处理到第几个图片    print(&#x27;处理中：&#123;&#125;/&#123;&#125;&#x27;.format(n, l))    n += 1# 将结果存储到txt文件res = np.array(result)np.savetxt(&#x27;result.txt&#x27;, res, fmt=&quot;%d&quot;, delimiter=&#x27;,&#x27;)print(&#x27;finished&#x27;)\n\nget_all_featureimport find_featureimport numpy as npimport osall_real_F = []path_real = &#x27;dataset/training_real&#x27;# 目录下有多少文件l = len(os.listdir(path_real))i = 1# 遍历每一个文件for file in os.listdir(path_real):    # 获取文件路径    file_path = os.path.join(path_real, file)    # 通过之前写的文件find_feature来获取该图片的特征值，存在F中    F = find_feature.find_feature(file_path)    all_real_F.append(F)    # 显示目前处理到第几个图片    print(&#x27;处理中：&#123;&#125;/&#123;&#125;&#x27;.format(i, l))    i += 1print(&#x27;finished&#x27;)# 将数据存储到txt文件data = np.array(all_real_F)np.savetxt(&#x27;modle/real_data.txt&#x27;, data, fmt=&quot;%.4f&quot;, delimiter=&#x27;,&#x27;)\n\ntrain_bayesian_modleimport numpy as np# 加载数据real_data = np.loadtxt(&#x27;modle/real_data.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)fake_data = np.loadtxt(&#x27;modle/fake_data.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)lr = len(real_data)lf = len(fake_data)# 求P(C)P_real = lr / (lr + lf)P_fake = lf / (lr + lf)PC = np.array([P_real,P_fake])# 分别求每个特征的概率judge = [[1, 5], [0.35, 1.5], [4, 20], [4, 14], [7, 28], [9, 50], [6, 50], [15, 80]]fr = [[], [], [], [], [], [], [], []]Pfr = [[], [], [], [], [], [], [], []]for i in range(0, 8):    fr[i] = np.array([0, 0, 0])    l = lr    for item in real_data:        if item[i] == -1:            l=l-1            continue        elif item[i] &lt; judge[i][0]:            fr[i][0] += 1        elif item[i] &lt; judge[i][1]:            fr[i][1] += 1        else:            fr[i][2] += 1    Pfr[i] = fr[i] / lff = [[], [], [], [], [], [], [], []]Pff = [[], [], [], [], [], [], [], []]for i in range(0, 8):    ff[i] = np.array([0, 0, 0])    l =lf    for item in fake_data:        if item[i] == -1:            l =l-1            continue        elif item[i] &lt; judge[i][0]:            ff[i][0] += 1        elif item[i] &lt; judge[i][1]:            ff[i][1] += 1        else:            ff[i][2] += 1    Pff[i] = ff[i] / lnp.savetxt(&#x27;modle/PC.txt&#x27;, PC, fmt=&quot;%.5f&quot;, delimiter=&#x27;,&#x27;)np.savetxt(&#x27;modle/real_P.txt&#x27;, Pfr, fmt=&quot;%.5f&quot;, delimiter=&#x27;,&#x27;)np.savetxt(&#x27;modle/fake_P.txt&#x27;, Pff, fmt=&quot;%.5f&quot;, delimiter=&#x27;,&#x27;)\n\ncheck_real_or_fakeimport numpy as npimport osimport find_feature# 加载数据PC = np.loadtxt(&#x27;modle/PC.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)Pfr = np.loadtxt(&#x27;modle/real_p.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)Pff = np.loadtxt(&#x27;modle/fake_P.txt&#x27;, dtype=&#x27;float32&#x27;, delimiter=&#x27;,&#x27;)judge = [[1, 5], [0.35, 1.5], [4, 20], [4, 14], [7, 28], [9, 50], [6, 50], [15, 80]]result = []path_test = &#x27;dataset/testing&#x27;# 获取目录下图片数量l = len(os.listdir(path_test))n = 1# 遍历每一个图片for file in os.listdir(path_test):    # 获取该文件路径    file_path = os.path.join(path_test, file)    # 通过之前写的文件find_feature来获取该图片的特征值，存在F中    F = find_feature.find_feature(file_path)    # 判断待测图片特征值和目标特征值的范围，并乘以对应概率    Ptest = PC[:]    for i in range(0,8):        if F[i] ==-1:            break        elif F[i]&lt; judge[i][0]:            Ptest[0] = Ptest[0]*Pfr[i][0]            Ptest[1] = Ptest[1]*Pff[i][0]        elif F[i]&lt; judge[i][1]:            Ptest[0] = Ptest[0] * Pfr[i][1]            Ptest[1] = Ptest[1] * Pff[i][1]        else:            Ptest[0] = Ptest[0] * Pfr[i][2]            Ptest[1] = Ptest[1] * Pff[i][2]    # 如果将该图片为真的概率大于假的概率则将其判断为真    if Ptest[0]&gt;Ptest[1]:        result.append(1)    else:        result.append(-1)    # 显示目前处理到第几个图片    print(&#x27;处理中：&#123;&#125;/&#123;&#125;&#x27;.format(n, l))    n += 1# 将结果存储到txt文件res = np.array(result)np.savetxt(&#x27;result.txt&#x27;, res, fmt=&quot;%d&quot;, delimiter=&#x27;,&#x27;)print(&#x27;finished&#x27;)\n\n存在问题\n特征选取数量少，类别仅为位置，而没有颜色纹理等（能力有限）\n\n特征值判断标准即judge数组的选取，缺乏依据，经过调整结果可能会变好\n\n由于上述问题导致结果全都是-1即判断全为假\n\n\n","categories":["人工智能课程"],"tags":["python","study note","machine learning"]},{"title":"基于Dehazenet的去雾卷积神经网络","url":"/2022/05/01/mlClass/MLClass-3/","content":"前言啊哈哈哈哈哈，第三次作业来喽……\n这次花了好久的时间去学习pytorch，然后自己搭建出了一个CNN模型，进行去雾。emm然而效果还是不好\n题目\n提供55张有雾图像以及对应的无雾图像\n建立网络，训练模型\n利用模型对测试集进行去雾并通过DHQI进行打分\n\n实现准备工作安装CUDA（可选）\nCUDA是NV的利用GPU进行数据处理的工具包，可以加快模型训练\n\n进入CUDA官网选择自己显卡对应的CUDA版本，可以百度搜索一下，我之前跟着教程下了CUDA10.1但是我的显卡用不了还得重安装，这里是官网的对应表，可以查看自己显卡驱动对应的CUDA版本\n\n\n\n\nCUDA Toolkit\nToolkit Driver Version\n\n\n\nversion\nWindows x86_64 Driver Version\n\n\nCUDA 11.6 Update 2\n&gt;=511.65\n\n\nCUDA 11.6 Update 1\n&gt;=511.65\n\n\nCUDA 11.6 GA\n&gt;=511.23\n\n\nCUDA 11.5 Update 2\n&gt;=496.13\n\n\nCUDA 11.5 Update 1\n&gt;=496.13\n\n\nCUDA 11.5 GA\n&gt;=496.04\n\n\nCUDA 11.4 Update 4\n&gt;=472.50\n\n\nCUDA 11.4 Update 3\n&gt;=472.50\n\n\nCUDA 11.4 Update 2\n&gt;=471.41\n\n\nCUDA 11.4 Update 1\n&gt;=471.41\n\n\nCUDA 11.4.0 GA\n&gt;=471.11\n\n\nCUDA 11.3.1 Update 1\n&gt;=465.89\n\n\nCUDA 11.3.0 GA\n&gt;=465.89\n\n\nCUDA 11.2.2 Update 2\n&gt;=461.33\n\n\nCUDA 11.2.1 Update 1\n&gt;=461.09\n\n\nCUDA 11.2.0 GA\n&gt;=460.82\n\n\nCUDA 11.1.1 Update 1\n&gt;=456.81\n\n\nCUDA 11.1 GA\n&gt;=456.38\n\n\nCUDA 11.0.3 Update 1\n&gt;= 451.82\n\n\nCUDA 11.0.2 GA\n&gt;= 451.48\n\n\nCUDA 11.0.1 RC\n&gt;= 451.22\n\n\nCUDA 10.2.89\n&gt;= 441.22\n\n\nCUDA 10.1\n&gt;= 418.96\n\n\nCUDA 10.0.130\n&gt;= 411.31\n\n\nCUDA 9.2 (9.2.148 Update 1)\n&gt;= 398.26\n\n\nCUDA 9.2 (9.2.88)\n&gt;= 397.44\n\n\nCUDA 9.1 (9.1.85)\n&gt;= 391.29\n\n\nCUDA 9.0 (9.0.76)\n&gt;= 385.54\n\n\nCUDA 8.0 (8.0.61 GA2)\n&gt;= 376.51\n\n\nCUDA 8.0 (8.0.44)\n&gt;= 369.30\n\n\nCUDA 7.5 (7.5.16)\n&gt;= 353.66\n\n\nCUDA 7.0 (7.0.28)\n&gt;= 347.62\n\n\n\n\n安装Pytorch\n我用的是anaconda，所有就新建环境，然后在环境中安装\n如果安装了CUDA需要去pytorch官网查找对应版本的pytorch\n\n# 新建环境# py37是虚拟环境的名字可以自行修改conda create -n py37 python=3.7# 激活环境conda activate py37# 去官网查找对应CUDA版本的pytorch# 我的CUDA版本是11.0所以找到对应的pytorch安装命令conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=11.0 -c pytorch\n\n算法原理\n建立大气模型：I(x) = J(x) t(x) + A ( 1 - t(x) )\nI(x)是有雾图像，J(x)是无雾图像，t(x)是大气透射率，A是全局大气光\n通过该公式可是反推出无雾图像\n\n\n建立卷积神经网络计算t(x)和A\n网络结构如下\n\n\n代码read_data.py\n建立读取数据以及数据预处理类\n\nimport torchfrom torch.utils.data import Datasetfrom PIL import Imageimport osfrom torchvision import transformsclass MyData(Dataset):    def __init__(self, root_dir, label_dir):        self.root_dir = root_dir        self.label_dir = label_dir        self.path = os.path.join(self.root_dir, self.label_dir)        # 获取列表中所有文件名        self.img_path = os.listdir(self.path)    def __getitem__(self, idx):        # 获取idx下标文件路径        img_name = self.img_path[idx]        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)        # 打开图片        img = Image.open(img_item_path)        # 新建totensor转换器        ToTensor = transforms.ToTensor()        # 判断图片尺寸        if img.width != 1600:            # 把尺寸不合适得图片转换为宽1600高1200            img = img.resize((1600, 1200))        # 将图片转换为tensor格式        img_ts = torch.reshape(ToTensor(img), (1, 3, 1200, 1600))        label = self.label_dir        return img_ts, label    def __len__(self):        return len(self.img_path)\n\nmodel.py\n建立卷积神经网络模型\n\nfrom torch.nn import Module, Sequential, Conv2d, ReLU, MaxPool2d, Upsample, Sigmoid, Flatten, Linearclass DeHazeNet(Module):    def __init__(self):        super(DeHazeNet, self).__init__()        # 获取大气透射率t(x)        self.get_tx = Sequential(            # 7*7卷积层-ReLU非线性激活-2*2最大池化层-上采样层            Conv2d(3, 5, 7, padding=3),            ReLU(),            MaxPool2d(2),            Upsample(scale_factor=2),            # 5*5卷积层-ReLU非线性激活-2*2最大池化层-上采样层            Conv2d(5, 5, 5, padding=2),            ReLU(),            MaxPool2d(2),            Upsample(scale_factor=2),            # 3*3卷积层-ReLU非线性激活-2*2最大池化层-上采样层            Conv2d(5, 10, 3, padding=1),            ReLU(),            MaxPool2d(2),            Upsample(scale_factor=2),            # 1*1卷积层-Sigmoid()非线性激活            Conv2d(10, 1, 1),            Sigmoid()        )        # 获取全球大气光成分A        self.get_A = Sequential(            # 11-9-7卷积池化            Conv2d(3, 5, 11, padding=10, dilation=2),            MaxPool2d(4),            Conv2d(5, 5, 9, padding=8, dilation=2),            MaxPool2d(4),            Conv2d(5, 5, 7, padding=6, dilation=2),            MaxPool2d(4),            # 全连接层            Flatten(),            # 线性层将2250维转换为1维            Linear(2250, 256),            Linear(256, 10),            Linear(10, 1)        )    def forward(self, x):        # 正向        tx = self.get_tx(x)        A = self.get_A(x)        return tx, A\n\ntrain.py\n训练模块\n\nimport torchfrom torch.nn import MSELossfrom torch.utils.tensorboard import SummaryWriterfrom model import DeHazeNetfrom read_data import MyDatadef get_Jx(img, tx, a):    # 通过透射率tx 和大气光成分a 恢复原图    # 公式：J(x) = ( (I(x)-A) / (max(tx,t0) ) ) + A    j = torch.add(img, -a)    ones = torch.ones_like(tx)    ones = torch.mul(ones, 0.1)    t = torch.where(tx &gt; 0.1, tx, ones)    j = torch.div(j, t)    j = torch.add(j, a)    return j# 导入训练集root_dir = &#x27;dataset/train&#x27;dataset_gt = MyData(root_dir, &#x27;GT&#x27;)dataset_haze = MyData(root_dir, &#x27;hazy&#x27;)# 创建网络dhn = DeHazeNet()# 创建损失函数 平方差loss = MSELoss()# 创建优化函数SGD 学习率0.007optim = torch.optim.SGD(dhn.parameters(), lr=0.007)# 是否使用GPU处理if torch.cuda.is_available():    dhn = dhn.cuda()    loss = loss.cuda()# 创建tensorboard得日志记录器writer = SummaryWriter(&#x27;logs&#x27;)# 初始化参数train = Trueepoch = 0# 开始训练while train:    running_loss = 0.0    epoch += 1    for i in range(len(dataset_haze)):        # 进度        print(&quot;\\rtraining... epoch: %d pic: %d/%d&quot; % (epoch, i+1, 55), flush=True, end=&#x27;&#x27;)        # 获取数据和目标        img, haze = dataset_haze[i]        target, gt = dataset_gt[i]        # GPU        if torch.cuda.is_available():            img = img.cuda()            target = target.cuda()        # 正向传递        tx, a = dhn(img)        # 恢复原图        Jx = get_Jx(img, tx, a)        # 计算损失        result = loss(Jx, target)        # 优化参数        optim.zero_grad()        result.backward()        optim.step()        # 计算总损失        running_loss += result    print(&#x27;\\nloss:&#123;&#125;\\n------------------------&#x27;.format(running_loss))    # 记录日志    writer.add_scalar(&#x27;loss&#x27;, running_loss, epoch)    # 判断结束条件    if running_loss &lt; 3 or epoch &gt; 100:        train = Falseprint(&#x27;training finished, saving...&#x27;)# 关闭日志记录writer.close()# 保存模型torch.save(dhn, &#x27;model_dhn.pth&#x27;)print(&#x27;save successfully.&#x27;)\n\nuse_model.pyimport torchfrom torchvision import transformsfrom read_data import MyDatadef get_Jx(img, tx, a):    # 通过透射率tx 和大气光成分a 恢复原图    # 公式：J(x) = ( (I(x)-A) / (max(tx,t0) ) ) + A    j = torch.add(img, -a)    ones = torch.ones_like(tx)    ones = torch.mul(ones, 0.1)    t = torch.where(tx &gt; 0.1, tx, ones)    j = torch.div(j, t)    j = torch.add(j, a)    return j# 导入测试集test_dir = &#x27;dataset/test&#x27;testset = MyData(test_dir, &#x27;haze&#x27;)# 导入训练好的模型dhn = torch.load(&#x27;model_dhn.pth&#x27;)# 使用GPUif torch.cuda.is_available():    dhn = dhn.cuda()for i in range(6):    test_ts, h = testset[i]    input_ts = test_ts    # 使用GPU    if torch.cuda.is_available():        input_ts = input_ts.cuda()    tx, a = dhn(input_ts)    Jx = get_Jx(input_ts, tx, a)    Jx = torch.reshape(Jx, (3, 1200, 1600))    ToPil = transforms.ToPILImage()    new = ToPil(Jx)    # new.show()    new.save(&#x27;result/dh&#123;&#125;.jpg&#x27;.format(i+1))\n\n存在问题\n可能使训练次数较少，或许使模型不合理，去雾的图像会有明显的失真彩色条带\n训练数据集太小仅有55张，\n听其他组报告得知可以根据大气模型伪造一些有雾图片，扩大数据集\n\n\n由于每次训练初始参数随机，导致有一次我训练500轮但是效果完全没有，去雾图像和有雾图像只能说是一模一样，还不如我之前仅训练77次的\n可以先少训练几次看看效果再决定要不要继续，反正可以保存模型\n\n\n\n\n参考文献：\n[1] 王高峰,张赛,张亚南,邵倩,高涛.基于改进DehazeNet的图像去雾方法[J].计算机系统应用,2021,30(05):208-213.DOI:10.15888/j.cnki.csa.007910.\n[2] DehazeNet个人学习笔记\n\n","categories":["人工智能课程"],"tags":["python","study note","machine learning"]},{"title":"第一篇文章","url":"/2021/03/16/other/first-blog/","content":"你好！我是第一篇文章这几天用hexo + github的方式搭建了自己的博客\n并用了keep的主题\n在这个过程中遇到了很多问题，不过在各种尝试下解决了\n之后打算自己写一个主题（大概）\n然后还会出一篇搭建hexo的教程把我遇到的问题和踩的坑写出来，网上的教程还是几年前的，会出现一些问题\n最后再学一下markdown的语法吧都快忘了\n","tags":["胡言乱语"]},{"title":"Java学习笔记-入门","url":"/2021/07/28/javaStudy/javaStudyNote-1/","content":"1.写在前面之前很小的时候很喜欢Minecraft，到现在也是，当时就想要写一些mod，然后MC是用Java写的，所以就接触过一点，但是后来不了了之了。\n后来又经历了几次有兴趣又放弃的过程，现在参加了一个比赛项目需要用到Java的相关知识，希望这次能够好好学完。\n2.Java的历史3.Java的特性\n面向对象\n高效\n没有指针\n不需要内存管理\n\n4.安装以及配置5.万恶之源Hello Worldpublic class study()&#123;    public static void main(String args[])&#123;        System.out.print(&quot;Hello World !&quot;);    &#125;&#125;\n\n\n保存为study.java\n\nCMD切到该目录下\n\njavac study.java\n#编译\njava study\n#运行\n\n\n\n6.Java运行机制\n编译型：翻译一整本书 C/C++\n\n解释型：有翻译官可以随时翻译 Javascript/Python\n\nJava先编译，后解释\n\n\n7. IDEA\nIDE: 集成开发环境\npsvm + Tab= public static void main(String[] args)&#123;&#125;\nsout +Tab= System.out.println();\n\n","categories":["Java学习笔记"],"tags":["study note","Java"]},{"title":"java学习笔记-流程控制","url":"/2021/07/31/javaStudy/javaStudyNote-3/","content":"1.用户交互Scannerimport java.util.Scanner;//导入Scanner包 public class Study&#123;     public static void main(String args[])&#123;                  Scanner scanner = new Scanner(System.in);         //创建扫描器                  if (scanner.hasNext())&#123;             //使用.hasNext()判断是否有输入             System.out.print(scanner.next());             //使用.next()获取输入         &#125;                  scanner.close();         //关闭，节省资源     &#125; &#125;\n\n\nnext()：以空格为结束符，第一个有效字符前面的空格不记入\n\nnextLine()：以回车为结束符\n\nnextInt()/nextFloat()/…..   :  接收整数/小数/……\n\n案例：\nimport java.util.Scanner; public class Study&#123;     public static void main(String args[])&#123;                  Scanner scanner = new Scanner(System.in);                  double sum = 0;         int num = 0;                  while(scanner.hasNextDouble())&#123;             double x = scanner.nextDouble();             num ++;             sum += x;         &#125;                  System.out.print(&#x27;平均数是：&#x27; + (sum/num));                  scanner.close();     &#125; &#125;\n\n2.顺序结构3.选择结构if\n单选：if(条件)&#123;成立时语句&#125;\n\n双选：if(条件)&#123;成立时&#125;else&#123;不成立时&#125;\n\n多选：if(条件1)&#123;1成立时&#125;else if(条件2)&#123;1不成立&amp;2成立&#125;else&#123;都不成立&#125;\npublic class Study&#123;    public static void main(String args[])&#123;        Scanner scanner = new Scanner(System.in);                String s = scanner.nextLine();        if (s.equals(&#x27;Hello&#x27;))&#123;            //字符串.equals()判断字符串是否相等            System.out.print(s);        &#125;else if(s.equals(&#x27;World&#x27;)&#123;            System.out.print(s);        &#125;else&#123;            System.out.print(&#x27;emmm&#x27;);        &#125;                scanner.close();    &#125;&#125;\nif嵌套\nif()&#123;    if()&#123;     &#125;&#125;\n\nswitch\n判断是否与一系列值中的某个值相等\n\ncase穿透：如果没有break就会一直往下输出,所以要都加break\n\nJDK7+ 可以匹配字符串，底层是通过哈希值匹配\n\n反编译：把生成的class文件放进IDEA\npublic class Study&#123;    public static void main(String args[])&#123;        char grade = &#x27;C&#x27;;                switch (grade)&#123;            case &#x27;A&#x27;:                System.out.print(&#x27;优秀&#x27;);                break;            case &#x27;B&#x27;:                System.out.print(&#x27;良好&#x27;);                break;            case &#x27;C&#x27;:                System.out.print(&#x27;及格&#x27;);                break;            case &#x27;D&#x27;:                System.out.print(&#x27;挂科&#x27;);                break;            default:                System.out.print(&#x27;未知&#x27;);                break;        &#125;    &#125;&#125;\n\n5.循环结构while\n只要条件为true 就一直循环\n\nwhile(条件)&#123;    语句;&#125;\n\npublic class Study&#123;    public static void main(String args[])&#123;                int i = 0;        int sum = 0;                while(i&lt;=100)&#123;            sum = sum + i;            i ++ ;        &#125;                System.out.print(sum);    &#125;&#125;\n\n\ndo while\n\n即使不满足也要执行一次\n先执行后判断\n\ndo &#123;    &#125;while();\n\nfor\n最有效最灵活的循环结构\n\nfor(初始化;条件;更新)&#123;    &#125;\n\npublic class Study&#123;    public static void main(String args[])&#123;                int odd = 0;        int even = 0;                for(int i=0; i&lt;=100; i++)&#123;            if(i%2==0)&#123;                even += i;            &#125;else&#123;                odd += i;            &#125;        &#125;                System.out.print(sum);    &#125;&#125;\n\n\n嵌套循环\nfor(int i=1; i&lt;10; i++)&#123;    for(int j=1; j&lt;10; j++)&#123;            &#125;&#125;\n增强型\nfor(初始化:数组)&#123;    &#125;\ncontinue：中止某次循环\n\ngoto：了解\n\n练习：打印三角形\n\n\npublic class Study&#123;    public static void main(String[] args)&#123;        for(int i = 1; i&lt;=5; i++)&#123;            for(int j=5; j&gt;=i; j--)&#123;                System.out.print(&#x27; &#x27;);            &#125;            for(int j=1; j&lt;i; j++)&#123;                System.out.print(&#x27;*&#x27;);            &#125;            for(int j=1; j&lt;=i; j++)&#123;                System.out.print(&#x27;*&#x27;);            &#125;            System.out.println();        &#125;    &#125;&#125;//输出结果//     *//    ***//   *****//  *******// *********\n\n\n\n\n\n","categories":["Java学习笔记"],"tags":["study note","Java"]},{"title":"java学习笔记-基础语法","url":"/2021/07/29/javaStudy/javaStudyNote-2/","content":"1.注释\n书写注释是一个非常好的习惯\n\n// 这是单行注释/*    这是   多行   注释*/ /** *  @Description 这是文档注释 *  @Author alcedoM */\n\n2.标识符和关键字\nJava所有的组成部分都需要名字，类名，变量名，方法名都被称为标识符\n\n只能以（A-Z/a-z/$/_）开头，之后可以是（A-Z/a-z/$/下划线/数字）的任意组合\n\n不能用关键字作为标识符\n\n大小写敏感\n\nex: name, $name, _name\n\n\n3.数据类型\n强类型语言，所有变量先定义才能使用\n\nJava的数据类型分为\n\n基本类型\n\n整数类型（数字之间可以用下划线分割：1_000_000）\n\nbyte\nshort\nint\nlong long num = 10L;\n\n\n浮点类型\n\nfloat float num = 3.14F;\ndouble\n\n\n字符类型\n\nchar\n\n\n字符串\n\nString(不是关键字，是类)\n\n\n布尔类型\n\nboolean\n\n\n\n\n引用类型\n\n类\n接口\n数组\n\n\n\n\n字节： 位（bit)–&gt;字节（byte/B）–&gt; 1024byte = 1KB\n\n进制\nint i = 10;//默认十进制int i = 010; //八进制前面加0int i = 0x10;//十六进制前面加0x\n浮点数扩展\n\n避免使用浮点型进行比较\n避免使用浮点型进行比较\n避免使用浮点型进行比较\n\nfloat f = 0.1f;double d = 1.0/10;System.out.print(f);System.out.print(d);System.out.print(f==d);//输出结果：0.1 0.1 false\n字符拓展\n\n强制转换可以把字符转换为数字\n\nA = 65； a = 97；大小写直接差32\n\n转义字符\n\n\\n 换行\n\\t 制表符\n……\n\n\n思考\nString a = new String(&#x27;hello world&#x27;);String b = new String(&#x27;hello world&#x27;);String c = &#x27;hello world&#x27;;String d = &#x27;hello world&#x27;;System.out.print(a==b);System.out.print(c==d);//输出结果第一个false 第二个true\n\n\n布尔值扩展\nboolean flag = true;if (flag == true)&#123;&#125;;if (flag)&#123;&#125;;//2，3行完全等价\n类型转换\n\n优先级：byte, short, char-&gt; int-&gt; long-&gt; float-&gt; double\n\n强制转换（高到低）：(类型)变量\n\n自动转换（低到高）\n\n注意\n\n不能对布尔类型进行转换 \n不能把对象类型转化为不相干的类型\n强制转换存在内存溢出和精度问题\n\nint money = 10_0000_0000;int years = 20;long total = money * years;//内存溢出，money和years先以int类型计算后转换为longlong total2 = money * ((long)years);//解决\n\n\n\n4.变量\n作用域\n\n类变量：有static修饰\n\n实例变量：类里方法外，从属于对象\n\n局部变量：只在方法里面有用\npublic class Study&#123;        static String name = &#x27;balabala&#x27;;    //类变量        int age;    //实例变量，从属对象，可以不初始化，有默认值        public class void main(String[] args)&#123;        int i = 10 ;        //局部变量，必须初始化                Study a = new Study;        System.out.print(a.age);        //实例变量，可以直接用，默认为0/0.0/null/false                System.out.print(name);        //类变量，不需要new对象可以直接用    &#125;&#125;\n\n\n常量：用final修饰，不可更改\n\n变量命名规范\n\n见名知意\n变量：首字母小写+驼峰：lastName\n常量：大写字母+下划线分割：MAX_VALUE\n类名：首字母大写+驼峰：Hello, HelloWorld\n方法名：首字母小写+驼峰：runApp()\n\n\n\n5.运算符\n\n\n类型\n内容\n\n\n\n算数\n+，-，*，/，%，++，–\n\n\n赋值\n=\n\n\n关系\n&gt;，&lt;，==，&gt;=，&lt;=，!=，instanceof\n\n\n逻辑\n&amp;&amp;，||，!\n\n\n位\n&amp;，|，^(相同取0不同取1)，~（取反），&gt;&gt;（/2），&lt;&lt;（*2），&gt;&gt;&gt;\n\n\n三元\n条件？成立时：不成立时\n\n\n扩展\n+=，-=，*=，/=\n\n\n\n优先级（）\n\n6.包机制\n一般用公司域名倒置作为包名\npackage com.alcedo.www;import java.util;//导包public class.....\n\n7.JavaDoc\njavadoc命令是用来生成自己API文档\n\nJava API文档\n/** * @author Alcedo * @version 1.0 * @since 1.8 * @param  * @throws * @return */\n\n# 命令行javadoc -encoding UTF-8 -charset UTF-8 xxx.java\n或者在IDEA中直接生成\n\n\n","categories":["Java学习笔记"],"tags":["study note","Java"]},{"title":"java学习笔记-方法","url":"/2021/07/31/javaStudy/javaStudyNote-4/","content":"1.什么是方法\nSystem.out.print()System类，out对象，print()方法\n方法的命名：首字母小写+驼峰\nJava方法是语句的集合，一起执行一个功能\n方法是解决一类问题的步骤的有序组合\n方法包含于类或对象中\n方法在程序中被创建，在其他地方被应用\n\n\n设计原则：一个方法完成一个功能\n\n2.方法的定义修饰符 返回类型 方法名（参数类型 参数名）&#123;\t···\t方法体\t···\treturn 返回值;&#125;public static int add(a,b)&#123;    return a+b;&#125;\n\n\nreturn：返回值、结束方法\nvoid：不返回值\njava是值传递\n\n3.方法的重载\n在同一个类中有相同的函数名，可以通过不同的参数类型来重载\n规则\n方法名相同\n参数列表不同（个数，类型，排列）\n\n\n\n4.命令行传参（不常用）public class Study&#123;    public static void main(String[] args)&#123;        for(int i=0; i&lt;args.length; i++)&#123;            System.out.println(args[i]);        &#125;    &#125;&#125;\n\njavac Study.javacd ../../../# 切换到srcjava xxx.xxx.xxx.Study hello world !# 输出# hello# world# !\n\n\n注意，用CMD进行编译，执行时要退回到src目录，并且加上包名\n传参，在执行的时候后面加上字符串，会以空格分开\n\n5.可变参数（不定项参数）\n可变参数int... num\n一个方法只能有一个可变参数，且必须在最后\n\npublic static int(int a, int... b)&#123;    &#125;\n\n6.递归\nA方法自己调用自己\n\n利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模小的问题求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大的减少了程序的代码量\n\n包含两部分\n\n递归头：什么时候不调用自身\n递归体：什么时候需要调用自身\n\n\n阶乘的实现\npublic static int f(int n)&#123;    if(n==1)&#123;        return 1;    &#125;else&#123;        return n*f(n-1);    &#125;&#125;\n前阶段，边界条件，返回阶段\n\n能不用就不用，在基数较小的时候可以用递归简化\n\n\n","categories":["Java学习笔记"],"tags":["study note","Java"]},{"title":"java学习笔记-面向对象","url":"/2021/08/02/javaStudy/javaStudyNote-6/","content":"1.什么是面向对象（oop）\n面对过程\n\n步骤清晰\n适合处理一些简单的问题\n\n\n面对对象\n\n物以类聚，分类的思想，思考解决问题需要哪些分类，然后对这些分类进行单独思考，最后对每一个类进行面对对象思考\n适合处理一些复杂的问题\n\n\n本质：以类的方法组织代码，以对象的形式封装数据\n\n特征：封装，继承，多态\n\n从认识角度，先有对象后抽象出类\n\n从代码角度，现有类后创建对象\n\n\n2.方法回顾\n方法的调用\n\n静态方法：static修饰，可以直接使用\n非静态方法：需要先实例化类对象类型 对象名称 = new 对象类型()\n静态方法中不能直接调用非静态方法\n\n\n值传递和引用传递\n\n值传递\n\npublic class Study&#123;    public static void main(String[] args)&#123;        int a = 1;        System.out.println(a);        Study.change(a);        System.out.println(a);    &#125;        public static void change(int a)&#123;        a = 10;    &#125;&#125;//结果两次输出都是1\n\n\n引用传递(对象)\n\npublic class Study&#123;    public static void main(String[] args)&#123;    \tStudent student = new Student();        System.out.println(student.name);        Study.change(student);        System.out.println(student.name);    &#125;        public static void change(Student student)&#123;        student.name = &quot;Alcedo&quot;;    &#125;&#125;class Student&#123;    String name;&#125;//第一次输出null，第二次输出Alcedo\n\n3.创建与初始化对象\n类里面只有属性和方法\n\nthis表示当前类\npublic class Study&#123;    public static void main(String[] args)&#123;    \t//类实例化之后会返回一个对(具体实例)        Student a = new Student();        a.name = &quot;alcedo&quot;;        a.age = 10;    &#125;   &#125;class Student&#123;    String name;    int age;        public void study()&#123;        System.out.println(this.name+&quot;在学习....&quot;)    &#125;&#125;\n\n\n构造器\n\n使用new必须有构造器\n不写会有默认构造器（隐式定义）\n必须和类的名字相同\n没有返回值\n\npublic class Person&#123;    String name;        public Person()&#123;    &#125;        //有参构造，一旦定义了有参构造，无参构造就必须显式定义    public Person(String name)&#123;        this.name = name;    &#125;&#125;\n\n\nIDEA中使用alt+insert自动生成构造器\n\n\n\n4.三大特征封装\n该露的露，该藏的藏\n\n高内聚低耦合，尽量暴露少量方法给外部使用\n\n属性私有，get/set\n\nprivate修饰属性\n\n通过get() / set()方法获取操作属性，同时可以进行安全性检查\n\nIDEAalt+insert -&gt; getter setter可以直接生成get/set方法\npublic class Student&#123;        //属性私有,加private修饰    private String name;    private int age;        //get,set:定义get(),set()函数来实现获取操作属性    public String getName()&#123;        return this.name;    &#125;        public int getAge()&#123;        return this.age;    &#125;        public void setName(String name)&#123;        this.name = name;    &#125;&#125;\n\n\n意义\n\n提高程序安全性，保护数据\n隐藏代码的实现细节\n统一接口\n提高系统可维护性\n\n\n\n继承\n继承的本质是对某一批类的抽象，从而实现对现实世界的更好的建模\n通过extends继承，只能单继承\n子类和父类之间应该具有’is a’的关系，比如：Student is a Person\n\npublic class Person&#123;    //父类&#125;//------------------------------两个文件----------------------------public class Student extends Person&#123;    //子类&#125;\n\n\n子类具有父类的所有public方法和属性，私有（private）无法被继承\n所有类都默认继承Object类\n\nsuper - this\nthis：调用当前类\nsuper：调用父类\n子类的构造器中默认有父类的无参构造器，如果在子类构造器中显示写出父类的构造器必须在第一句\n\n方法重写\n需要有继承关系，子类重写父类的方法。\n方法名必须相同\n参数列表必须相同\n必须是非静态方法\n修 饰符：范围可以扩大不能缩小：public &gt; protected&gt; default&gt;private\n抛出异常：范围可以被缩小不能扩大\n\npublic class A extends B&#123;    public static void test()&#123;        System.out.println(&quot;A-test()&quot;)    &#125;&#125;//------------------------------两个文件----------------------------public class B &#123;    public static void test()&#123;        System.out.println(&quot;B-test()&quot;)    &#125;&#125;//------------------------------两个文件----------------------------import com.alcedo.A;import com.alcedo.B;public class Study&#123;    public static void main(String[] args)&#123;                //静态方法的调用只和定义的数据类型有关        A a = new A();        a.test();        //父类的引用可以指向子类，因为子类继承父类        B b = new A();        b.test();            &#125;&#125;//结果第一个是“A-test”第二个是“B-test”\n\n\npublic class A extends B&#123;    //@Override 重写方法，只有非静态且public的才能重写    @Override    public void test()&#123;        System.out.println(&quot;A-test()&quot;)    &#125;&#125;//------------------------------两个文件----------------------------public class B &#123;    public void test()&#123;        System.out.println(&quot;B-test()&quot;)    &#125;&#125;//------------------------------两个文件----------------------------import com.alcedo.A;import com.alcedo.B;public class Study&#123;    public static void main(String[] args)&#123;                A a = new A();        a.test();        //子类重写了父类的方法        B b = new A();        b.test();            &#125;&#125;//结果都是输出“A-test”\n\n多态\n同一方法可以根据发送对象的不同而采用不同的行为方式\n注意事项\n多态是方法的多态，\n父类和子类，有联系   才类型转化\n存在条件： 继承关系，方法重写，父类的引用指向子类对象Father f1 = new Son()\n是否能调用方法看引用类型\n上例中Father是引用类型Son是实际类型\n引用类型有，走引用类型\n引用类型有，且实际类型中被重写，走实际类型\n引用类型没有，实际类型有，需要类型转换\n\n\n\n\ninstanceof + 类型转换\nX instanceof Y 判断XY之间是否存在父子关系（只要是一条线上的都返回True，Ex：Object &gt; Father &gt; Son）\n(class) variableName 强制转换\n\n\n\npublic class Person&#123;    public void run()&#123;           System.out.print(&quot;p-run&quot;);    &#125;    public void eat()&#123;        System.out.print(&quot;p-eat&quot;);\t&#125;&#125;//------------------------------两个文件----------------------------public class Student extends Person&#123;    @Override    public void eat()&#123;        System.out.print(&quot;s-eat&quot;);\t&#125;    public void study()&#123;        System.out.print(&quot;study&quot;);\t&#125;&#125;//------------------------------两个文件----------------------------public class Study&#123;    public static void main(String[] args)&#123;                //一个对象的实际类型是确定的，指向的引用类型就不一定了        //父类的引用可以指向子类        Student s1 = new Student();        Person s2 = new Student();                s2.run(); //1. 引用类型有，走引用类型,结果为p-run       \ts2.eat();//2. 引用类型有，且实际类型中被重写，走实际类型，结果为s-eat        //s2.study(); //报错        ((Student) s2).study();//3. 引用类型没有，实际类型有，需要类型转换            &#125;&#125;\n\n5.抽象类\nabstract修饰\n抽象类的所有方法需要子类去重写\n特点\n作为约束\n不能实例化(不能new)\n抽象类可以写普通方法/抽象方法\n抽象方法必须写在抽象类中\n\n\n\n//抽象类public abstract class Study&#123;    //抽象方法    public abstract void test();&#125;//------------------------------两个文件----------------------------publuc class S extends Study&#123;    //必须重写方法    @Override    public void test()&#123;            &#125;&#125;\n\n6.接口\n只有规范，没有自己的实现，不能写方法，不能被实例化\n规范和实现分离\n可以实现多继承\n\n//通过interface定义public interface Service&#123;    int AGE = 99;    //接口中的所有属性都是常量    //等同于public static final int AGE = 99;    //一般不这么写        void add(int age);    //接口中的所有函数都是抽象    //等同于public abstract void add(int age); &#125;//------------------------------两个文件----------------------------public interface TimeService&#123;    void timer();&#125;\n\n\n通过类来实现接口,必须重写方法，通过implement关键字实现\n通过implement可以实现多个接口\n\npublic class ServiceImpl implement Service,TimeService&#123;    @Override    public void add(int age)&#123;            &#125;        @Override    public void timmer()&#123;            &#125;&#125;\n\n7.内部类成员内部类\n内部类会生成独立的文件\n内部类可以直接获取到外部类的私有属性\n内部类属性和外部类属性名相同，优先获取内部的属性，获取外部类则需要 Outer.this.name\n内部类不能包含静态属性，但可以包含静态常量\n\npublic class Outer&#123;    private int id = 10;    public void out()&#123;        System.out.println(&quot;out&quot;);    &#125;        class Inner&#123;        private int id = 2;        public void in()&#123;            System.out.println(&quot;in&quot;);        &#125;        public void getId()&#123;            System.out.print(id);            System.out.print(Outer.this.id);        &#125;    &#125;&#125;//------------------------------两个文件----------------------------public class Test&#123;    public static void main(String[] args)&#123;        Outer outer = new Outer();        Outer.Inner inner = outer.new Inner();        //通过外部类实例化内部类                inner.getId();        //结果：2，10        //优先读取内部类的属性        //内部类可以直接获取到外部类的私有属性    &#125;&#125;\n\n静态内部类\nj级别上约等于外部类。\n可以直接创建，不需要先创建外部类对象。\n可以包括静态属性。\n静态内部类中的方法调用外部类属性需要先创建外部类对象。\n\npublic class Outer&#123;    private int id = 10;    private String addr = &quot;China&quot;;            static class Inner&#123;        private static int id = 2;        public void getId()&#123;                      Outer outer = new Outer();            System.out.print(outer.id);            //静态内部类中的方法调用外部类属性需要先创建外部类对象。        &#125;            &#125;&#125;//------------------------------两个文件----------------------------public class Test&#123;    public static void main(String[] args)&#123;               \tOuter.Inner inner = new Outer.Inner();        //可以直接创建内部类    &#125;&#125;\n\n局部内部类\n定义在外部类的方法里面\n不能添加修饰符如：private\n可以直接访问外部类的属性 \n不能包含静态属性\n\npublic class Outer&#123;    private int a = 10;        public void method()&#123;        final String addr = &quot;china&quot;;        //如果局部内部类使用了该变量则默认为常量，jdk1.8+可以不添加final修饰 \t\tclass Inner2&#123;            //xxxxx;            Systerm.out.print(addr);\t\t&#125;\t&#125;&#125;\n\n匿名内部类\n类似于局部内部类\n必须继承一个父类或者实现一个接口\n定义类，实现类，创建对象的语法合并\n只能创建一个对象\n\npublic class Test&#123;    public static void main(String args[])&#123;    \tUsb usb = new Usb()&#123;        \t@override        \tpublic void service()&#123;        \t    System.out.print(&quot;~~~&quot;);        \t&#125;    \t&#125;;    \tusb.service();    &#125;&#125;//------------------------------两个文件----------------------------public interface Usb&#123;    void service();&#125;","categories":["Java学习笔记"],"tags":["study note","Java"]},{"title":"java学习笔记-数组","url":"/2021/08/01/javaStudy/javaStudyNote-5/","content":"1.什么是数组\n数组是相同类型数据的有序集合\n每一个数据成为数组的一个元素，可以通过下标来访问每一个元素\n\n2.数组的声明与创建//声明数组dataType[] arrayName;//首选的方法^,或者如下vdataType arrayName[];//创建数组dataType[] arrayName = new dataType[number];//赋值arrayName[index] = xxx;//静态初始化int[] a = &#123;1,2,3,4,5&#125;;//动态初始化int[] b = new int[10];b[index] = xxx;\n\n\n获取数组长度：array.length\n\n3.内存分析\njava内存\n堆\n存放new的对象和数组\n可以被所有线程共享\n\n\n栈\n存放基本变量类型\n引用对象的变量\n\n\n方法区\n可以被所有线程共享\n包含了所有static变量和class\n\n\n\n\n\n4.数组基本特征\n数组的长度一旦被创建就不可更改\n元素必须是相同类型\n元素可以是任何基础类型或引用类型\n数组对象本身在堆中\n数组下标从0开始到（length-1）\n\n5. 多维数组int[][] a = new int[2][5];\n\n6.Arrays类\n\n\n方法\n功能\n\n\n\nArrays.toString()\n打印数组\n\n\nArrays.sort()\n排序升序\n\n\nArrays.fill()\n给数组赋值\n\n\nArrays.equals()\n比较数组中元素是否相等\n\n\nArrays.binarySearch()\n对排好序的数组进行二分法查找\n\n\n7.冒泡排序public class Study&#123;    public static void main(String[] args)&#123;            &#125;        public static void sort(int[] array)&#123;        for(int i=0; i&lt;array.length-1; i++)&#123;            for(int j=0; j&lt;array.length-1-i; j++)&#123;                if(array[j+1]&lt;array[j])&#123;                    int mid  = array[j+1];                    array[j+1] = array[j];                    array[j] = mid;                &#125;            &#125;        &#125;        System.out.print(Array.toString(array));    &#125;&#125;\n\n\n时间复杂度O(n2)\n\n8.稀疏数组\n当数组中大部分元素相同，可以用稀疏数组保存\n处理方法\n记录数组一共有几行几列，有多少不同值\n把具体不同值的元素行列和值记录在一个小规模的数组中\n\n\n时间换空间\n\npublic class Study &#123;    public static void main(String[] args)&#123;        //原始数组        int[][] array1 = new int[11][11];        array1[1][1] = 1;        array1[2][3] = 2;        //转化        int[][] array2 = toLittle(array1);        //还原        int[][] array3 = recover(array2);        //打印比较        printArray(array1);        printArray(array2);        printArray(array3);    &#125;        //转化方法    public static int[][] toLittle(int[][] array1)&#123;        //转化为稀疏数组        //获取不同的元素个数        int count = 0;        for(int i =0; i&lt;array1.length; i++)&#123;            for(int j=0; j&lt;array1[0].length; j++)&#123;                if(array1[i][j]!=0)&#123;                    count++;                &#125;            &#125;        &#125;        //创建稀疏数组        int[][] array2 = new int[count+1][3];        array2[0][0] = array1.length;        array2[0][1] = array1[0].length;        array2[0][2] = count;        //填充        int row = 1;        for(int i =0; i&lt;array1.length; i++)&#123;            for(int j=0; j&lt;array1[0].length; j++)&#123;                if(array1[i][j]!=0)&#123;                    array2[row][0] = i;                    array2[row][1] = j;                    array2[row][2] = array1[i][j];                    row ++;                &#125;            &#125;        &#125;        return array2;    &#125;        //还原方法    public static int[][] recover(int[][] array2)&#123;        int[][] array1 = new int[array2[0][0]][array2[0][1]];        for(int i=1; i&lt; array2.length; i++)&#123;            array1[array2[i][0]][array2[i][1]] = array2[i][2];        &#125;        return array1;    &#125;        //打印方法    public static void printArray(int[][] array)&#123;        System.out.println(&quot;==============================&quot;);        for(int i=0; i&lt;array.length; i++)&#123;            for(int j=0; j&lt;array[0].length; j++)&#123;                System.out.print(array[i][j]+&quot;\\t&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n","categories":["Java学习笔记"],"tags":["study note","Java"]},{"title":"java学习笔记-异常","url":"/2021/08/03/javaStudy/javaStudyNote-7/","content":"1.异常(Exception)分类\n检查性异常\n运行时异常\n错误（Error）比较致命\nError是Java虚拟机生成并抛出，大多数错误与代码的编写者所执行的操作无关。\nJava虚拟机运行错误–java虚拟机会选择线程中止\n\n\n\n2.异常处理机制\n捕获异常\n\n假设捕获多个异常，范围从小到大Throwable &gt; Error = Exception &gt; ArithmeticException\npublic class Study&#123;    public static void main(String args[])&#123;\t\tint a = 1;        int b = 0;                try&#123;            System.out.print(a/b);\t\t&#125;catch(ArithmeticException ae)&#123;//catch(想要捕获的异常类型)            System.out.print(&#x27;程序出现异常&#x27;);        &#125;catch (Exception e)&#123;                    &#125;catch (Throwable t)&#123;                    &#125;finally&#123;//处理善后工作            System.out.print(&#x27;finally&#x27;);        &#125;    &#125;&#125;\n主动抛出异常：throws用在方法上向上级抛出异常，throw用在方法中\npublic class Study&#123;    public static void main(String[] args)&#123;                try&#123;//try监控区域            Study s = new Study();        \ts.test(1,0);        &#125;catch (ArithmeticException e)&#123;            System.out.print(&quot;b不能为零&quot;);        &#125;finally&#123;            System.out.print(&quot;finally&quot;);        &#125;            &#125;            public void test(int a, int b) throws ArithmeticException&#123;        if(b==0)&#123;        \tthrow new ArithmeticException();        \t//主动抛出异常一般在方法中        &#125;        System.out.print(a/b);    &#125;&#125;\n\n3.自定义异常\n需要继承异常类\n\npublic class Ex extends Exception&#123;        //传递数字&gt;10    private int detail;        public Ex(int a)&#123;        detail = a;    &#125;        @Override    public String toString()&#123;        return &quot;Ex&#123;&quot; + &quot;detail=&quot; + detail + &#x27;&#125;&#x27;;    &#125;    &#125;\n\n","categories":["Java学习笔记"],"tags":["study note","Java"]},{"title":"hexo备份的重要性","url":"/2021/07/28/hexo/hexo-backup/","content":"写在前面好久没有写blog了，中间也发生了很多事情，发现当时心血来潮买的mini主机并没有经常用到，而且虚拟机也是个好东西，然后就把它卖了。\n然而我忘了我有3篇关于deepin的文章是在那个电脑上写的，我没有存回来。\n刚刚发现的时候顿时就慌了\n不过好在自己的网站上还有，而且可以复制下来，直接就是markdown的语法，很快恢复了三篇文章。\n经此一事，我决定直接把hexo的文件全部备份到github上。\n步骤\n在github上创建新的仓库比如hexo-backup\n\n在本地的hexo文件夹下打开git bush\n\ngit init\n#初始化\ngit remote add origin https://github.com/yourname/hexo-backup.git\n#添加远程仓库\ngit add *\ngit commit -m &quot;backup yy/mm/dd&quot;\ngit push origin master\n#push到远程仓库\n\n\n\n后记我是新建了一个仓库，也可以在原来的仓库新建分支\n我还是小白，不是很懂，搞了半天没有成功，而且我也怕影响到博客的静态页面\nso可以参考Hexo备份与恢复\n","categories":["分享"],"tags":["hexo"]},{"title":"Hexo + Github 分分钟搭建属于自己的博客","url":"/2021/03/17/hexo/hexo-blog-website/","content":"前言我来啦，第一篇分享就来教教如何搭建自己的博客吧！就像你看到这样。\n之前一直以为搭建一个自己的网站费时费力费钱，但是现在才知道Github，才知道并不用费很多心力在前期准备上，可以投入到内容的创作。\n通过Hexo，可以快速构建个人博客，并搭建到 Github 上供他人访问。\n重点是免费喔\n不管你是一位ITer想搭建技术博客，还是一个普通人只想记录生活，看看总没错！\nHexo 介绍Hexo是一个快速、简洁且高效的博客框架，具有较完善的体系生态，也是一个正在不断开发完善的框架。\nHexo 会解析 markdown 语法 生成对应的 html 并展示在你的网站上。\n官方主页\n中文文档\n准备1.Github注册打开Github官网如图\n点击Sign in登录Sign up注册\n\n创建新的仓库页面右上头像旁边的加号 点击New repository\n\n把仓库命名为yourname.github.io\nyourname最好和你的用户名一致\n比如：我就应该命名为alcedoM.github.io\n点击Create repository\n\n2.创建本地项目在合适的位置创建一个文件夹，这个文件夹将是Hexo博客的本地调试、修改，文章创作，上传等的地方\n3.安装GitGit 是用来从本地上传代码到你创建的Github仓库的。可以上传、修改Hexo的本体以及之后的文章\n到Git官网下载符合自己系统的Git版本\n检查打开Git Bash输入以下内容检查（$不用自己输入）\n$ git --version\n\n有如下显示你就成功了\n\n4.node.js到node.js官网下载node.js\n建议下载LTS版本并安装\n检查打开Git Bash输入以下代码检查\n$ npm -v$ node -v\n\n有如下显示你就成功了\n\n恭喜你已经完成准备工作！\nHexo 安装来到刚刚创建的空文件夹下，右键菜单，选择Git Bash Here\n\n或者直接打开Git，使用$ cd 盘符:/文件夹/.../目标文件夹 来达到你的文件夹。例如：\n$ cd e:/hexo\n\n输入命令安装hexo\n$ npm install hexo-cli -g\n\n等待完成后输入命令检查\n$ hexo -v\n\n输入命令初始化hexo\n$ hexo init\n\n输入命令补全未安装的组件\n$ npm install\n\n输入命令生成相关文件\n$ hexo g\n\n\n\n这时你的文件夹下就会生成下列信息\n\nnode_modules: 依赖包\n\npublic：存放生成的页面\n\nscaffolds：生成文章的一些模板\n\nsource：用来存放你的文章\n\nthemes：主题\n\n_config.yml: 博客的配置文件之后会有很多调整\n\n\n输入命令打开hexo本地服务\n$ hexo s\n\n这时打开浏览器输入https://localhost:4000就可以看到博客界面啦\n这个亚子\n\n按ctrl + C可以中止服务\n恭喜你已经完成hexo安装！\nHexo 部署1.生成SSH配置到github生成SSH打开Git Bash输入命令,其中yourname填写你的GitHub用户名youremail填写你的GitHub邮箱\n$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot;\n\n输入命令检查是否填写正确\n$ git config user.name$ git config user.email\n\n输入命令生成SSH\n$ ssh-keygen -t rsa -C &quot;youremail&quot;\n\n打开生成时告诉你的目录，一般在C:/用户/&quot;你的用户名&quot;/.ssh\n用记事本（或其他应用）打开id_rsa.pub文件复制其中的密钥（全选）\n\n配置到Github打开Github，右上角点击头像，下拉菜单找到settings\n\n右边栏找到SSH and GPG keys之后点击New SSH key\n\ntitle随意，key填入之前的密钥，点击Add SSH key\n回到Git Bash输入命令检查是否成功\n$ ssh -T git@github.com\n\n2.部署hexo修改配置找到并打开站点配置文件 _config.yml，翻到最后，修改为：\nyourname是你的GitHub用户名\ndeploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;yourname.github.io.git  branch: main\n\n安装deploy-git回到Git Bash输入命令\n$ npm install hexo-deployer-git --save\n\n部署文件输入命令清除之前的文件\n$ hexo clean\n\n重新生成文章和网页\n$ hexo g\n\n部署到GIthub\n$ hexo d\n\n\n\n第一次在hexo d的时候会弹框要求输入你GitHub的用户名和密码\n部署完成你就可以在你对应的仓库看到你上传的文件\n这时在地址栏输入yourname.github.io就可以看到你的网站啦\n恭喜你部署Hexo成功！\nHexo 文章写作1.写文章在你的hexo文件夹下右键打开Git Bash创建新文章\nyour-article-name 可以自己取\n$ hexo new your-article-name\n\n这时在./source/_posts文件夹下可以看到your-article-name.md就是你的文章啦！\n建议安装相应的markdown编辑软件来进行编辑。\nmarkdown很简单啦不要被吓到！！！\n参考&gt;markdown软件 | markdown语法\n2.预览回到Git Bash输入命令\n$ hexo clean$ hexo g$ hexo s\n\n这时就可以在localhost:4000预览\n3.上传回到Git Bash上传\n$ hexo clean$ hexo g$ hexo d\n\n这时就可以在你的博客看到更新啦\n更换主题我遇到的问题1.安装git和node后输入node -v无反应\n解决\n建议安装目录就在C盘不要修改\n\n2.安装hexo后 输入$ hexo -v报错\n解决 \n我当时是因为node.js 版本过低，从官网下载最新版后成功\n\n3.部署时失败\n解决\n网络问题，有些地方访问不了GitHub，建议翻墙\n目录下.deploy_git有问题，建议删除再hexo clean|hexo g|hexo d\n\n","categories":["分享"],"tags":["hexo"]},{"title":"hexo配置","url":"/2021/03/19/hexo/hexo-config/","content":"前言上篇文章忘记讲hexo的配置问题了\n很简单噢\n配置\n打开hexo根目录找到_config.yml打开\n\n1.site# Sitetitle:    subtitle: description: keywords:author: language: timezone: \n\ntitle后面的文字会显示在标题栏，如图\n\nsubtitle:\n网站副标题\n\ndescription:\n网站描述\n\nauthor:\n作者（你的）名字\n\nlanguage:\n网站语言 建议zh-cn\n\ntimezone:\n时区，Hexo 默认使用您电脑的时区\n\n2.url# URLurl: http:&#x2F;&#x2F;yourname.github.ioroot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults:\n\nurl:\n填写你网站的地址 http://yourname.github.io\n\nroot:\n网站根目录 填**”/“**\n\npermalink:\n文章的 永久链接 格式\n比如我新建一个文章叫test.md，那么这个的地址就是http://yoursite.com/2021/03/18/test\n还有其他格式比如\n:year/:month/:day/:title/\n:year-:month-:day-:title.html\n:category/:title    \n\n\n\npermalink_defaults:\n永久链接中各部分的默认值\n\n3.Extensions# Extensionstheme: \n\n更换主题的地方\n更换主题教程\n域名绑定如果不想使用yourname.github.io这个来访问的话也可以自己绑定域名噢\n比如我就绑定了alcedo.work\n域名是需要购买的建议去阿里云之类的地方购买，.com .cn这些常见的比较贵，但是.top .work之类的就很便宜还有优惠啥的\n域名购买阿里云\n搜索想要的域名，并购买\n域名解析\n登录阿里云\n打开右上角控制台\n我的导航-&gt;域名\n找到你购买的域名，右边点击解析\n添加记录如图\n\n\n\n注意CNAME一定要大写\n192.30.252.154和192.30.252.153是github的服务器地址\n\n域名绑定\n进入GitHub仓库打开Settings\n\n\n\n向下找到Custom domain并填写你的域名\n\n\n\n在hexo根目录的/source文件夹下创建名为CNAME（大写）的文件，内容就写你的域名，最后记得把.txt的后缀删了\n\n\n\n记得在hexo的配置文件_config.yml下把url改为你的域名\n回到GitBash输入命令\n\n$ hexo clean$ hexo g$ hexo d\n\n过一小会就可以用你的域名访问你的博客了\n","categories":["分享"],"tags":["hexo"]},{"title":"hexo主题更换","url":"/2021/03/19/hexo/hexo-theme/","content":"前言emmm这是第二遍写了，上次忘记保存然后莫得了\n看到这篇文章想必你一定时成功安装好了hexo\n还没有？\n快去看Hexo + Github 分分钟搭建属于自己的博客\nhexo最初的主题可能不是很和你的胃口，想要找到更符合自己审美的主题\n下面就来告诉大家如去更换主题\n找主题hexo官方网站提供了很多（334个）主题共大家选择.\n打开后就可以看到如下图所示\n\n点击图片到预览网站\n点击蓝色名字进入对应的Github项目\n\n\n其实在知乎，CSDN上搜索hexo主题也有很多有用的文章噢\n尽情选择吧！\n主题下载\n一般很流行的主题都会有自己的官方教程\n一般在GitHub的项目下也会有README.md的参考文档，建议阅读\n下面以我用的Keep主题为例\n\n1.官方（推荐）阅读主题的官方网页\n或者阅读在GitHub的项目下的README.md参考文档，按照步骤来进行安装配置，如图\n\n2.Clone-命令下载（推荐）点击选中主题下的蓝色标题，进入其GitHub项目\n如图绿色的框框，选SSH，复制代码\n回到hexo的根文件夹下右键打开Git Bash\n粘贴命令并执行，等待安装完毕\n\n3.直接下载上图蓝色框点击Download ZIP下载压缩包\n解压后放入/themes/keep文件夹下（注意不是/themes/keep/keep也不是/themes）\n不管是哪种方式最后都应该是这样（注意路径是一般情况，以官方文档为准）\n\n使用主题\n注意一下会出现两个_config.yml文件\n一个是hexo的配置文件在根目录下，一个是主题的配置文件在你安装好的主题文件夹下\n\n1.选取打开hexo的配置文件_config.yml找到theme:\n如图，keep要换成你主题的名字，并保存\n\n在hexo根目录下打开Git Bash输入命令\n$ hexo clean$ hexo g$ hexo s\n\n等完成之后，你就可以在本地localhost:4000下看到你的主题了\n2.配置我只挑一些有用的，其他建议参考官方网页或官方README.md文档\nkeep官网\n打开主题的配置文件_config.yml\nbase_infobase_info:  title: Keep Theme  author: Keep Team  url: https://keep.xpoet.cn/\n\n请在该配置项里正确填写你网站的基本信息。\n\ntitle 网站标题（将显示在网站头部，如下图） \nauthor 作者昵称（将显示在网站底部和文章内容页，如下图）\n网站底部 \n文章内容页 \n\n\nurl 网站域名填写你的域名或yourname.github.io（将用于在文章内容页的版权信息模块正确拼接文章链接，如下图） \n\navatar设置作者头像，将显示在文章内容页，如下图。  你可以使用本地图片（即存储 keep/source/images/ 路径下的图片）或图片外链 URL。写法参考：\n\n本地图片\navatar: /images/avatar.svg\n图片外链\navatar: https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg\n\nfavicon设置网站 favicon 图标，你可以使用本地图片（即存储 keep/source/images/ 路径下的图片）或图片外链 URL。 \nhome_articlehome_article:  category:    enable: false     # show category in home page article block    limit: 3          # max number of categories shown in home page article block  tag:    enable: false     # show tags in home page article block    limit: 5          # max number of tags shown in home page article block\n\n该配置项用于设置首页文章块底部的标签和分类信息显示。\n\ncategory 文章分类\ntag 文章标签\nlimit 限制显示的个数\n效果图\n不开启效果 \n开启效果 \n\n\n\ntag 和 category添加在文章的开头部分,如下\ntitle: xxxxxxdate: xxxx-xx-xx xx:xx:xxtags: xxxxcategories: xxxx\n\n\n\n3.部署在本地预览确认无误后，在hexo根目录下打开Git Bash输入命令\n$ hexo clean$ hexo g$ hexo d\n\n等待上传完成\n可能需要过几分钟就可以在yourname.github.io下看到你更换的主题了\n","categories":["分享"],"tags":["hexo"]},{"title":"java学习笔记-常用类","url":"/2022/07/01/javaStudy/javaStudyNote-8/","content":"Object类getClass()\n返回引用中存储的实际对象类型\n\nhashCode()\n返回对象的hash值，int类型\n一般相同对象返回的哈希值相同\n\ntoString()\n返回该对象的字符串表示\n可以根据需求重写该方法，默认返回：字符串表示@十六进制哈希值\n源码：return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\n\n//重写toString()    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;;    &#125;\n\nequals()\n比较两个对象是否相同\n可以根据需求重写该方法\n源码：return (this == obj);\n\n//重写equals\t@Override    public boolean equals(Object obj)&#123;//        判断两个对象是否为同一个引用        if(this==obj)&#123;            return true;        &#125;//        判断obj是否为空        if(obj==null)&#123;            return false;        &#125;//        判断是否为同一个类型        if(obj instanceof Student)&#123;//            强制转换            Student s = (Student)obj;//            比较属性            if(this.name.equals(s.getName()) &amp;&amp; this.age==s.getAge())&#123;                return true;            &#125;        &#125;        return false;    &#125;\n\nfinalize()\n当对象被判定为垃圾对象时，由JVM自动调用此方法，我们不用亲自调用该方法\n自动回收机制：内存不足的时候系统自动调用。\n手动回收机制：使用System.gc();通知JVM回收垃圾\n\n相关代码//测试类public class app &#123;    public static void main(String args[])&#123;        Student s1 = new Student(&quot;aaa&quot;, 20);        Student s2 = new Student(&quot;bbb&quot;, 22);        Class c1 = s1.getClass();        Class c2 = s1.getClass();        if (c1==c2)&#123;            System.out.println(&quot;两个类相同&quot;);        &#125;else&#123;            System.out.println(&quot;两个类不同&quot;);        &#125;        System.out.println(c1);        System.out.println(c2);        System.out.println(&quot;==================&quot;);//结果//两个类相同//class com.alcedo.demo3.Student//class com.alcedo.demo3.Student                int h1 = s1.hashCode();        int h2 = s2.hashCode();        if (h1==h2)&#123;            System.out.println(&quot;两个对象相同&quot;);        &#125;else&#123;            System.out.println(&quot;两个对象不同&quot;);        &#125;        System.out.println(h1);        System.out.println(h2);        System.out.println(&quot;==================&quot;);//结果//两个对象不同//460141958//1163157884        System.out.println(s1.toString());        System.out.println(s2.toString());        System.out.println(&quot;==================&quot;);//结果//com.alcedo.demo3.Student@1b6d3586//com.alcedo.demo3.Student@4554617c        System.out.println(s1.equals(s2));//结果//false    &#125;&#125;\n\n包装类\n包装类就是基本数据类型所对应的引用数据类型\n包装类的默认值是null\n\n类型转换：装箱拆箱\n把栈里面的数据拿到对立面变成对象叫装箱，即把基本类型转换为引用类型，反之为拆箱\n\n//装箱//基本类型int num1 = 10;//使用Integer类创建对象Integer integer1 = new Integer(num1);Integer integer2 = Integer.valueOf(num1);//拆箱//引用类型Integer integer3 = new Integer(100);int num2 = integer3.intValue();//JDK1.5之后,提供自动装箱拆箱int age = 20;//自动装箱Integer integer4 = age;//自动拆箱int age2 = integer4;\n\nparseXXX()//基本类型转字符串int n1 = 100;String s1 = n1 + &quot;&quot;;String s2 = Integer.toString(n1);//字符串转基本类型String str = &quot;150&quot;;int n2 = Integer.parseInt(str);//boolean字符串转基本类型，&quot;true&quot;--&gt;true,非&quot;true&quot;--&gt;falseString str2 = &quot;true&quot;;String str3 = &quot;sjdlf&quot;;boolean b1 = Boolean.parseBoolean(str2);//trueboolean b2 = Boolean.parseBoolean(str3);//false\n\n整数缓冲区\nJava预先创建了256个常用整数包装对象\n\n//面试题Integer integer1 = new Integer(10);Integer integer2 = new Integer(10);System.out.println(integer1==integer2);Integer integer3 = 100;Integer integer4 = 100;System.out.println(integer3==integer4);Integer integer5 = 200;Integer integer6 = 200;System.out.println(integer5==integer6);/*结果* false* true* false*/\n\n\ninteger1和2是分别创建的两个对象，故不相等\ninteger3,4,5,6是用的自动装箱，其实调用的是函数Integer.valueOf(100)。这个函数内部有一个整数缓冲区，自动帮我们创建好了-128到127共256个整数对象。当所给的数值在此区间内则直接将缓冲区的对象拿过来。即integer3,4所指向的对象都是缓冲区的100故为true\n而integer5,6超过了缓冲区范围，则是新创建的两个对象\n\n//valueOf()源码public static Integer valueOf(int i) &#123;    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);&#125;//IntegerCache.cache源码，high=127,low=-128cache = new Integer[(high - low) + 1];int j = low;for(int k = 0; k &lt; cache.length; k++)\tcache[k] = new Integer(j++);\n\nString类\n字符串是常量，创建之后不可改变\n字符串字面值存储在字符串池中，可以共享\n给字符串变量赋值时没有改变原来的数值，而是开辟新的空间创建新的字符串，改变指向地址。\nString str = new String();创建的字符串产生两个对象一个在堆中，一个在字符串池中。\n\n\n\n\n方法\n描述\n\n\n\nequals()\n比较两个字符串相等\n\n\nequalsIgnoreCase()\n忽略大小写比较两个字符串相等\n\n\ncompareTo()\n返回两个字符串第一个不同的字符在字典表里的差值，若都相同则比长度\n\n\nsubstring(begin, [end])\n截取对应位置的字符串\n\n\nlength()\n返回字符串长度\n\n\ncharAt(index)\n返回某个位置的字符\n\n\ncontains(str)\n判断是否包含某个子字符串\n\n\ntoCharArray()\n转换为字符数组\n\n\nindexOf(str, fromIndex)\n返回子字符串首次出现的位置\n\n\nlastIndexOf()\n返回子字符串末次出现的位置\n\n\ntrim()\n去掉字符串前后的空格\n\n\ntoUpperCase()/toLowerCase()\n大小写转换\n\n\nendsWith(str)/startsWith()\n判断是否以str开头或结尾\n\n\nreplace(old,new)\n字符/字符串替换\n\n\nsplit(str)\n根据str拆分,使用“[]”选择多个符号拆分\n\n\npublic class str &#123;    public static void main(String[] args) &#123;        String str = &quot;  java是世界上最好的编程语言，java真香  &quot;;        String str2 = &quot;This is a testing word, which include    more space.&quot;;                System.out.println(&quot;abc&quot;.compareTo(&quot;acb&quot;));        //-1   b:98  c:99 98-99=-1          System.out.println(&quot;abc&quot;.compareTo(&quot;abcdsef&quot;));        //-4   比长度3-7=4        System.out.println(str.substring(6));        //是世界上最好的编程语言，java真香          System.out.println(str.length());        //26        System.out.println(str.charAt(3));        //a        System.out.println(str.contains(&quot;java&quot;));        //true        char a[] = str.toCharArray();        System.out.print(&quot;[&quot;);        for(int i=0;i&lt;a.length;i++)&#123;            System.out.print(a[i]+&quot;, &quot;);        &#125;        System.out.print(&quot;]&quot;);        System.out.println();        //[ ,  , j, a, v, a, 是, 世, 界, 上, 最, 好, 的, 编, 程, 语, 言, ，, j, a, v, a, 真, 香,  ,  , ]        System.out.println(str.indexOf(&quot;java&quot;));        //2        System.out.println(str.trim());        //java是世界上最好的编程语言，java真香        System.out.println(str.toUpperCase());        //  JAVA是世界上最好的编程语言，JAVA真香        System.out.println(str.startsWith(&quot;  java&quot;));        //true        System.out.println(str.endsWith(&quot;java&quot;));        //false        System.out.println(str.replace(&quot;java&quot;,&quot;python&quot;));        //  python是世界上最好的编程语言，python真香        String b[] = str2.split(&quot;[ ,.]+&quot;);        //使用[]来选择多个分割符，+可以处理多个分隔符出现的情况        System.out.print(&quot;[&quot;);        for(int i=0;i&lt;b.length;i++)&#123;            System.out.print(b[i]+&quot;, &quot;);        &#125;        System.out.print(&quot;]&quot;);        System.out.println();        //[This, is, a, testing, word, which, include, more, space, ]    &#125;&#125;\n\nStringBuffer/StringBuilder类\n可变长字符串，效率比String高，节省内存\nBuffer线程安全，Builder线程不安全\nBuffer效率较低，Builder效率更高\n单线程使用StringBuilder\n\n\n\n\n方法\n描述\n\n\n\nappend()\n在后面添加\n\n\ninsert(index, str)\n指定位置插入\n\n\nreplace(begin,end,str)\n制定位置长度替换\n\n\ndelete(begin,end)\n删除指定位置片段\n\n\nStringBuffer str = new StringBuffer();//append()str.append(&quot;hello&quot;);System.out.println(str);str.append(&quot; world&quot;);System.out.println(str);//insert()str.insert(0,&quot;begin &quot;);System.out.println(str);//replace()str.replace(0,5,&quot;replace&quot;);System.out.println(str);//delete()str.delete(0,8);System.out.println(str);\n\nBigDecimal类\n精确计算浮点数，double是近似存储精度不足\n使用的时候一定要用字符串构造对象\n\n\n\n\n方法\n描述\n\n\n\nsubtract()\n减法\n\n\nadd()\n加法\n\n\nmultiply()\n乘法\n\n\ndivide(val, scale, roundingmode)\n除法，scale表示保留位数，roundingmode是近似模式，除不尽的情况要加后两个参数否则报错\n\n\nBigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);BigDecimal r1 = a.subtract(b);System.out.println(r1);//减法BigDecimal r2 = a.add(b);System.out.println(r2);//加法BigDecimal r3 = a.multiply(b);System.out.println(r3);//乘法BigDecimal r4 = new BigDecimal(&quot;1.4&quot;)        .subtract(new BigDecimal(&quot;0.5&quot;))        .divide(new BigDecimal(&quot;0.9&quot;));System.out.println(r4);//除法//用double算的话结果是0.9999999999BigDecimal r5 = new BigDecimal(&quot;10&quot;)    .divide(new BigDecimal(&quot;3&quot;),3,BigDecimal.ROUND_HALF_UP);System.out.println(r5);//除不尽的时候要给保留几位小数和保留模式，否则会报错\n\nDate类\n大部分方法已经过时，被Calendar类所替代\n\n\n\n\n方法\n描述\n\n\n\nafter()\n判断是否在一个时间之后，返回boolean\n\n\nbefore()\n判断是否在一个时间之前，返回boolean\n\n\ncompareTo()\n比较时间先后，返回1，0，-1\n\n\nequals()\n比较两个时间是否相同，返回boolean\n\n\nDate date1 = new Date();System.out.println(date1.toString());//获取当前时间Date date2 = new Date(date1.getTime()-60*60*24*1000);System.out.println(date2);//通过毫秒数构造boolean b1 = date1.after(date2);System.out.println(b1);boolean b2 =date1.before(date2);System.out.println(b2);int i = date1.compareTo(date2);System.out.println(i);boolean b3 = date1.equals(date2);System.out.println(b3);//结果//Fri Jul 08 16:50:51 GMT+08:00 2022//Thu Jul 07 16:50:51 GMT+08:00 2022//true//false//1//false\n\nCalendar类\n受保护，无法直接创建对象，通过getInstance()方法创建对象\n月份是0-11，记得加1\n\n\n\n\n方法\n描述\n\n\n\ngetInstance()\n获取当前时间对象\n\n\ngetTime()\nCalendar转换为Date对象\n\n\ngetTimeInMillis()\n获取毫秒值\n\n\nget(field)\n获取对应字段的时间信息Calendar.YEAR等\n\n\nset(field, value)\n设置时间\n\n\nadd(field,value)\n时间加减\n\n\ngetActualMaximum(field)\n获取当前字段的最大值例如获取月份最大天数\n\n\n//创建calendar对象Calendar calendar = Calendar.getInstance();System.out.println(calendar.getTime().toString());System.out.println(calendar.getTimeInMillis());//获取时间信息int year = calendar.get(Calendar.YEAR);int month = calendar.get(Calendar.MONTH);int day = calendar.get(Calendar.DAY_OF_MONTH);int hour = calendar.get(Calendar.HOUR);//Hour：12小时；Hour_OF_DAY：24小时制int minute = calendar.get(Calendar.MINUTE);int second = calendar.get(Calendar.SECOND);System.out.println(year +&quot;年&quot;+                    (month+1) +&quot;月&quot;+                   day+&quot;日&quot;+                   hour+&quot;时&quot;+                   minute+&quot;分&quot;+                   second+&quot;秒&quot;);//修改时间Calendar calendar2 = Calendar.getInstance();calendar2.set(Calendar.MONTH,1);System.out.println(calendar2.getTime().toLocaleString());//add设置时间calendar2.add(Calendar.HOUR_OF_DAY,2);System.out.println(calendar2.getTime().toLocaleString());//获取当前月份的最大最小天数int max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH);System.out.println(max);//结果//Fri Jul 08 17:21:16 GMT+08:00 2022//1657272076187//2022年7月8日5时21分16秒//2022-2-8 17:21:16//2022-2-8 19:21:16//28\n\nSimpleDateFormat类\n文本与日期互相转换，格式化\nparse方法需要抛出异常，因为有可能输入的字符串不符合规定\n日期格式：y年，M月，d日，H24小时，h12小时，m分，s秒\n\n\n\n\n方法\n描述\n\n\n\nformate(Date)\n将Date对象按给的格式格式化为字符串\n\n\nparse(String)\n将字符串按给定的格式解析为Date对象\n\n\npublic static void main(String[] args) throws Exception&#123;    //创建对象    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);    //创建Date    Date date = new Date();    //格式化Date    String str = sdf.format(date);    System.out.println(str);    //解析字符串    String str2 = &quot;2022/1/1 00:00:00&quot;;    Date date2 = sdf.parse(str2);    System.out.println(date2.toLocaleString());&#125;//结果//2022/07/08 17:36:56//2022-1-1 0:00:00\n\nSystem类\n主要用于获取系统的属性数据和其他操作\n\n\n\n\n方法\n描述\n\n\n\narraycopy()\n复制数组\n\n\ncurrentTimeMillis()\n获取当前系统时间\n\n\ngc()\n建议JVM启动垃圾回收\n\n\nexit(status)\n推出JVM，0正常，非零异常\n\n\n//数组复制//src:原数组//srcPos:从哪个位置复制//dest:目标数组//destPos:目标数组的位置//length:复制长度int[] src = &#123;1,14,45,63,78,9,55,30&#125;;int[] dest = new int[8];System.arraycopy(src,4,dest,2,4);for(int i=0;i&lt;src.length;i++)&#123;    System.out.println(dest[i]);&#125;//结果0 0 78 9 55 30 0 0//获取系统时间//可以用来实现计时System.out.println(System.currentTimeMillis());//结果：1657338754077//退出JVMSystem.exit(0);System.out.println(&quot;退出JVM&quot;);//不会打印，因为已经退出了\n\n","categories":["Java学习笔记"],"tags":["study note","Java"]}]